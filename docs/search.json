[
  {
    "objectID": "DELETE-LATER/practice.html",
    "href": "DELETE-LATER/practice.html",
    "title": "Here is my level one header",
    "section": "",
    "text": "Here is my level one header\nHere is my paragraph\nHere is my 2nd paragraph\nHere is my 3rd paragraph"
  },
  {
    "objectID": "blogs.html",
    "href": "blogs.html",
    "title": "Blog",
    "section": "",
    "text": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnalyzing Impacts of the Thomas Fire\n\n\n\nGIS\n\n\nRemote-Sensing\n\n\nMEDS\n\n\n\nIn Santa Barbara & Ventura Counties (Dec. 2017 - Jan. 2018)\n\n\n\nNicole\n\n\nOct 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnalyzing Impacts of the Thomas Fire\n\n\n\nGIS\n\n\nRemote-Sensing\n\n\nMEDS\n\n\n\nIn Santa Barbara & Ventura Counties (Dec. 2017 - Jan. 2018)\n\n\n\nNicole\n\n\nOct 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBlog Post Title\n\n\n\nQuarto\n\n\nMEDS\n\n\n\nThis is my interesting caption about the blog post\n\n\n\nNicole\n\n\nOct 18, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Nicole Pepper",
    "section": "",
    "text": "Hey there!\nI’m Nicole Pepper, a graduate student at the University of California, Santa Barbara, pursuing a Master’s in Environmental Data Science (MEDS) at the Bren School. My passion lies in leveraging spatial and diverse datasets to tackle pressing environmental challenges and inspire meaningful action. When I’m not wrangling data, you’ll find me enjoying the great outdoors, especially in the mountains. Take a look around to learn more about my work and the impact I’m striving to make.\n\n\nEducation\nUniversity of California Santa Barbara Masters in Environmental Data Science (Expected June 2025)\nUniversity of California Los Angeles B.A in Geography and Environmental Studies, Minor in Geospatial Information Systems & Technology (June 2018)\n\n\nProfessional Experience\nNASA Acres Program and Communications Coordinator (May 2023 - Present)"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "",
    "text": "---\ntitle: \"Analyzing Impacts of the Thomas Fire\"\ndescription: \"In Santa Barbara & Ventura Counties (Dec. 2017 - Jan. 2018)\"\nauthor: \n  - name: Nicole\n    url: https://github.com/nicolelpepper\n    affiliation: Bren MEDS\n    affiliation-url: https://bren.ucsb.edu/masters-programs/master-environmental-data-science/academics-meds-program\ndate: 2024-10-18\ncategories: [GIS, Remote-Sensing, MEDS]\nimage: thomas-fire.png\nbibliography: references.bib\ndraft-mode: visible\ncitation:\n      url: https://github.com/nicolelpepper/personalwebsite/2024-12-02-thomas-fire\neditor_options: \n  chunk_output_type: console\n---"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#in-santa-barbara-ventura-counties-dec.-2017---jan.-2018",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#in-santa-barbara-ventura-counties-dec.-2017---jan.-2018",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "In Santa Barbara & Ventura Counties (Dec. 2017 - Jan. 2018)",
    "text": "In Santa Barbara & Ventura Counties (Dec. 2017 - Jan. 2018)\nAuthor: Nicole Pepper\nThe Thomas Fire, which ignited on December 4, 2017, burned approximately 281,893 acres in Ventura and Santa Barbara counties, making it one of the largest and most devastating wildfires in California’s history. The fire left behind extensive burn scars with widespread loss of vegetation and unstable soil, leaving the region vulnerable to erosion. In 2018, heavy rains caused massive flooding and debris flows, which resulted in catastrophic damage and tragic loss of life.\nHere I share my beginner’s Python exercise exploring some of the impacts of the Thomas Fire using satellite imagery and air quality data."
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#part-1.-visualizing-the-thomas-fire-burn-scar-using-false-color",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#part-1.-visualizing-the-thomas-fire-burn-scar-using-false-color",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "Part 1. Visualizing the Thomas Fire burn scar using false color",
    "text": "Part 1. Visualizing the Thomas Fire burn scar using false color\nSatellite data can be used to visualize landscapes beyond what the bare eye can see. In this section I utilize true color and false color settings to visualize the Thomas Fire burn area.\nSome of the technical highlights for this section include working with satellite imagery with rioxr, working with geospatial data with geopandas, and creating a map with matplotlib.\n\nStep 1A: Set up my workspace\nTo begin work this exercise I set up my workspace by loading in the libraries that are necessary for the analysis:\n\n# ---- Load libraries ----\nimport os # interacting with operating system\nimport numpy as np # numeric computing\nimport matplotlib.pyplot as plt # data visualization\nimport pandas as pd # general data wrangling\nimport geopandas as gpd # geospatial data wrangling\nfrom shapely.geometry import Polygon # creating and manipulating geometric objects\nfrom pyproj import CRS # crs management\nimport rioxarray as rioxr # working with raster data\nimport xarray as xr # working with arrays\n\nThen I configure my working environment and establish a directory structure for managing the project data.\n\n# ---- Set working environment ----\n\n# Set anaconda environment\nos.environ['PROJ_LIB'] = '/opt/anaconda3/share/proj'\n\n# Set up a root path directory\nroot = os.path.join('/',\n                  'courses',\n                  'EDS220',\n                  'data',\n                  'hwk4_landsat_data')\n\n\n\nStep 1B: Import & prepare data\nNext it’s time to read in my project data.\nThe thomas_fire.shp is a shapefile containing the fire perimeter for the Thomas Fire in 2017. It is subset of a CAL FIRE dataset with historical boundaries for fires (including both natural and prescribed fires) in the state of California. The dataset has a good record of past large fires but is not complete and may be missing some fires. The thomas_fire.shp data is stored in /data/thomas_fire folder in the repo, I did not push the original full Cal Fire dataset to GitHub, it was accessed locally.\nThe landsat.nc dataset is an image from Landsat Collection 2 Level-2, from the Microsof Planetary Computer data catalogue. Landsat Collection 2 Level-2 Science Products consist of atmospherically corrected surface reflectance and surface temperature image data. Collection 2 Level-2 Science Products are available from August 22, 1982 to present. It is accessed through UCSB Workbench 1 /courses/EDS220/data/hwk4_landsat_data landsat8-2018-01-26-sb-simplified.nc.\n\n# ---- Import data ----\n\n# Import Thomas Fire boundary\nthomas_fire = gpd.read_file(\"data/thomas_fire/thomas_fire.shp\")\n\n# Import landsat .nc file\nfp = os.path.join(root,'landsat8-2018-01-26-sb-simplified.nc')\nlandsat = rioxr.open_rasterio(fp)\n\nNext, I will check the coordinate reference systems (CRS) of the landsat and thomas_fire datasets to ensure 1) the CRS aligns with the needs of the project and 2) the datasets share the same crs, allowing for proper overlay and analysis.\n\n# ---- Check CRS information ----\n\n# Check if landsat is projected \nprint(\"Is the landsat CRS projected?\", landsat.rio.crs.is_projected)\n\n# Check if thomas fire is projected \nprint(\"Is the thomas_fire CRS projected?\", thomas_fire.crs.is_projected)\n\n# Check if crs match\nprint(\"Do the crs match?\", landsat.rio.crs == thomas_fire.crs)\n\n# Print the crs name\nprint(\"The landsat CRS is:\", landsat.rio.crs)\n\n# Print the crs name\nprint(\"The thomas fire CRS is:\", thomas_fire.crs.name)\n\nIs the landsat CRS projected? True\nIs the thomas_fire CRS projected? True\nDo the crs match? False\nThe landsat CRS is: PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"World Geodetic System 1984\",SPHEROID[\"WGS 84\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]\nThe thomas fire CRS is: WGS_1984_Web_Mercator_Auxiliary_Sphere\n\n\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\n\n\nMy analysis found that the landsat and thomas_fire crs were both projected, but did not match. This means that we need to reproject the data to match. So next, I’m going to reproject the thomas_fire CRS is to match that landsat CRS which is EPSG 32611 or WGS 84 / UTM Zone 11N.\n\n# ---- Reproject CRS ----\n\n# Reproject to landsat crs\nthomas_fire = thomas_fire.to_crs(landsat.rio.crs)\n\n# Check if crs match\nprint(\"Do the crs match?\", landsat.rio.crs == thomas_fire.crs)\n\nDo the crs match? True\n\n\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\n\n\n\n\nStep 1C. Explore the Data\nNow that I have my data set up. I’m interested in learning more about the landsat data that I’ll be using. In the next code chunk, I explore different characteristics about my data.\n\n# ---- Explore data ----\n\n# Check out landsat data dimensions\nprint('Size of landsat dimensions: ', dict(landsat.sizes))\n\n# Check out the shape of the landsat data\nprint(\"The shape of Landsat is\", landsat.rio.shape)\n\n# Check out the variables of the landsat data\nprint(\"Variables in the Landsat data:\", list(landsat.data_vars))\n\n# Check out the original coordiantes of the landsat data\nprint(\"Variables in the Landsat data:\", list(landsat.coords))\n\nSize of landsat dimensions:  {'band': 1, 'x': 870, 'y': 731}\nThe shape of Landsat is (731, 870)\nVariables in the Landsat data: ['red', 'green', 'blue', 'nir08', 'swir22']\nVariables in the Landsat data: ['band', 'x', 'y', 'spatial_ref']\n\n\nThe landsat data is 870 by 731 pixels. It has has a total of a band length of 1 and the list of variables in the dataset are ‘red’, ‘green’, ‘blue’, ‘nir08’, and ‘swir22’.\n\n\nStep 1D. Prepare the landsat data for visualization\nSince the landsat data only has one band, I’m going to simplify it by dropping the dimensions that so that it’s easier to work with. To do this, I’ll use .squeeze() and .drop_vars() to remove the band length of 1.\n\n# Remove length 1 dimension (band) and reassign\nlandsat = landsat.squeeze().drop_vars('band', errors='ignore')\n\n# Check updated dimensions of the coordinates\nprint(landsat.dims, landsat.coords)\nprint('Size of landsat dimensions: ', dict(landsat.sizes))\n\nFrozenMappingWarningOnValuesAccess({'x': 870, 'y': 731}) Coordinates:\n  * x            (x) float64 7kB 1.213e+05 1.216e+05 ... 3.557e+05 3.559e+05\n  * y            (y) float64 6kB 3.952e+06 3.952e+06 ... 3.756e+06 3.755e+06\n    spatial_ref  int64 8B 0\nSize of landsat dimensions:  {'x': 870, 'y': 731}\n\n\nI can see that the extra dimension has been removed from the data! Yipee!\n\n\nStep 1E. Visualize the Landsat data in true color\nNow I want to take a look at the landsat data. First off, it would be helpful to see the study area in “natural-color” also known as “true-color’, so that I can get a sense of what the terrain looks like. True-color is a term used by remote sensing experts to describe displaying a satellite image in colors similar to what most people would naturally see with their bare eyes. This means plotting the ‘red’, ‘green’, and ‘blue’ bands in their respective order.\nHere I plot the landsat image in true color (R-G-B) to visualize what the burn area looks like over the region.\n\n# Plot the landsat bands in true color\nlandsat[['red', 'green', 'blue']].to_array().plot.imshow()\n\nplt.title(\"Thomas Fire Study Area\") # Add title\nplt.axis('off') # Removing axis labels and ticks\nplt.show() # Display the plot\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\n\n\n\n\n\n\n\nHmmmmm…. something here doesn’t look right! The map shows up in black and white when I was expecting it to look like a true color image.\nThis is because the clouds in the image introduce extreme, outlier values. By setting the robust = True parameter in the in .imshow(), I adjust the color scale based on the 2nd and 98th percentiles of the values, which helps minimize the influence of these outliers. This allows the color ramp to more accurately reflect the distribution of values where most of the data lies, providing a clearer representation of the underlying true color patterns in the image.\n\n# Plot the landsat bands in true color\nlandsat[['red', 'green', 'blue']].to_array().plot.imshow(robust=True) # scale on the 2 & 98th percentiles\n\nplt.title(\"Thomas Fire Study Area\") # Add title\nplt.axis('off') # Remove axis labels and ticks\nplt.show() # Display the plot\n\n\n\n\n\n\n\n\nAhhh, much better! Now this is more like what I was expecting to see in my true color image.\nThis map helps me get a feel for what the landscape looks like, but it is still difficult for me to distinguish between landcover like healthy vegetation and bare ground, since the green, brown, and tan colors don’t contrast strongly.\n\n\nStep 1F. Visualize the Landsat data in false\nNext, I’d like to see if I can visualize the burned area better by integrating other bands of the landsat image in a ‘false-color’ composite. False-color images use at least one wavelength outside the visible range, like near-infrared, which can highlight things that we can’t see with our bare eyes.\nVegetation strongly reflects in the near-infrared (NIR) and short-wave infrared (SWIR) bands and absorbs in the red, so visualizing these bands can help me distinguish between healthy vegetated from bare ground. For this reason, I will create a false-color composite using the SWIR, NIR, and red bands (SWIR-NIR-R) to better distinguish between vegetation and the Thomas Fire burned area.\n\n# Select and plot swir, nir, and red variables\nlandsat[['swir22', 'nir08', 'red']].to_array().plot.imshow(robust=True) # scale on the 2 & 98th percentiles\n\nplt.title(\"Thomas Fire Study Area\") # Add title\nplt.axis('off') # Remove axis labels and ticks\nplt.show() # Display the plot\n\n\n\n\n\n\n\n\nThat worked! Now I can much more easily distinguish between vegetation (green) and bare ground or stressed vegetation (tan and red). In the bottom right, I can make out a large irregular red shape which lines up with the area that the Thomas Fire burned.\n\n\nStep 1G. Overlay the Thomas Fire boundary on the false color image\nNow my final step is to overlay the false-color image with the Thomas Fire boundary to see how well the composite image picks up the burned area.\n\n# Select false color SWIR-NIR-red bands and set to array\nfalse_color = landsat[['swir22', 'nir08', 'red']].to_array()\n\n# Set aspect ratio for map\nfire_aspect_ratio = landsat.rio.shape[1] / landsat.rio.shape[0]\n\n# Set figure parameters\nfig, ax = plt.subplots(figsize=(6, 6*fire_aspect_ratio))\n\n# Add false color imagery for background\nfalse_color.plot.imshow(ax = ax,\n                        robust=True) \n# Add thomas fire boundary\nthomas_fire.boundary.plot(ax=ax,\n                color = \"#780B12\",\n                linewidth = 0.6,\n                alpha = 0.8)\n# Add title\nax.set_title('Thomas Fire Boundary (2017)         Southern California',\n            color=\"#222626\", \n            fontsize=12)\n\nax.axis('off') # Remove axis labels and ticks\nplt.legend(thomas_fire,loc='upper right', labels = [\"Thomas Fire\"]) # add legend\nplt.show() # Display the plot\n\n/tmp/ipykernel_3552418/3966502035.py:24: UserWarning: You have mixed positional and keyword arguments, some input may be discarded.\n  plt.legend(thomas_fire,loc='upper right', labels = [\"Thomas Fire\"]) # add legend\n\n\n\n\n\n\n\n\n\nThis map shows the burn perimeter, outlined in dark red, for the Thomas Fire which occured in 2017. The boundary is overlayed onto a false color satellite image of the region, combining short-wave infrared (SWIR), near-infrared (NIR), and red bands to highlight vegetation (green) versus the burn scar (red). This overlay shows that the boundary of the burn scar aligns well with area in red in false color composite. When looking back at the true color image, this false-color map demonstrates the ability of the false color images to pick out land surface characteristics beyond what our bare eyes can see.\n\n# Display all columns in preview\npd.set_option(\"display.max.columns\", None)"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#section",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#section",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "3",
    "text": "3\n\nand b. Use the next two code cells to look at the head of both data frames. Store your results in aqi_17_head and aqi_18_head.\n\n\n# a.\n# Look at the head, first 5 entries, of the AQI 2017 data\naqi_17_head = aqi_17.head()\n\n\n# b.\n# Look at the head, first 5 entries, of the AQI 2018 data\naqi_18_head = aqi_18.head()\n\nANSWER: - I used dtypes to see the data types for the different columns. - I used max and min to find the max and min AQI values for the datasets. - I used value_counts to find the value counts of observations that fell in the different Category Ratings\nI found that the means were similar between the years but the max for 2017 was much higher. I also found that in 2017 there were more ‘Hazardous’(71) category ratings than in 2018(30), which indicates that the presence of events in 2017 that contributed to low air quality.*"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#section-1",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#section-1",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "4",
    "text": "4\nWe currently have two separate data frames. For this exercise we will need to “glue” them one on top of the other. The pandas function pd.concat() can achieve this.\nPass [aqi_17, aqi_18] as the input of pd.concat() and store the output as aqi.\nIn the next line run aqi.\nNOTE: When we concatenate data frames like this, without any extra parameters for pd.concat() the indices for the two dataframes are just “glued together”, the index of the resulting dataframe is not updated to start from 0. Notice the mismatch between the index of aqi and the number of rows i the complete data frame.\n\n# Combine the two datasets using `pd.concat`\naqi = pd.concat([aqi_17, aqi_18])"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#section-2",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#section-2",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "5",
    "text": "5\nRun the following code cell and use the next markdown cell to give a line by line explanation of the code below the comment “#Simplify column names”. You might need to look up the pandas documentation.\n\n# Initial column names: notice caps and spaces (difficult to work with!)\nprint(aqi.columns, '\\n')\n\n# Simplify column names\naqi.columns = (aqi.columns\n                  .str.lower()\n                  .str.replace(' ','_')\n                )\nprint(aqi.columns, '\\n')\n\nIndex(['State Name', 'county Name', 'State Code', 'County Code', 'Date', 'AQI',\n       'Category', 'Defining Parameter', 'Defining Site',\n       'Number of Sites Reporting'],\n      dtype='object') \n\nIndex(['state_name', 'county_name', 'state_code', 'county_code', 'date', 'aqi',\n       'category', 'defining_parameter', 'defining_site',\n       'number_of_sites_reporting'],\n      dtype='object') \n\n\n\n\nLine by line explanation of above code\nANSWER:\n# Initial column names: notice caps and spaces (difficult to work with!)\nprint(aqi.columns, '\\n')               # Prints original column names and sets a new text line\n\n# Clean column names\naqi.columns = (aqi.columns # Select columns of the aqi dataframe      \n        .str.lower()  # Set text in column names to be lowercase\n                  .str.replace(' ','_')  # Replace spaces with underscore in column names\n              )\n              \n# Confirm column names updated successfully**\n- print(aqi.columns, '\\n')  # Print updated column names and sets a new text line"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#section-3",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#section-3",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "6",
    "text": "6\nIn the next code cell:\n\nSelect only data from Santa Barbara county and store it in a new variable aqi_sb.\nRemove the state_name, county_name, state_code and county_code columns from aqi_sb.\n\nYour dataframe should have the following columns in this order: date, aqi, category, defining_parameter, defining_stie, number_of_sites_reporting.\n\n# part a\n# Subset AQI data to Santa Barbara county\naqi_sb = aqi[aqi['county_name'] == 'Santa Barbara']\n\n# part b\n# Remove the 'state_name', 'county_name', 'state_code' and 'county_code' columns from aqi_sb\naqi_sb = aqi_sb.drop(['state_name', 'county_name', 'state_code', 'county_code'], axis = 1)\n\n\n\nWhat is the data type of the date column? Store your answer in the date_type variable. Your answer should contain the type for the date column only.\n\n\n# Check the type of date column\ndate_type = type(aqi_sb.date)"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#section-4",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#section-4",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "7",
    "text": "7\nIn the following cell: 1. Update the date column of aqi_sb to be a pandas.datetime object. 2. Update the index of aqi_sb to be the date column.\n\n# part a\n# Update the data column to datetime object\naqi_sb.date = pd.to_datetime(aqi_sb.date)\n\n# part b\n# Set date as the index of aqi_sb\naqi_sb = aqi_sb.set_index('date')"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#section-5",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#section-5",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "8",
    "text": "8\nIn the next cell we will calculate an average over a rolling window using the rolling()method for pandas.Series:\n\nrolling() is a lazy method, so we need to specify what we want to calculate over each window before it does something.\nin this example we use the aggregator function mean() to calculate the average over each window\nthe parameter ‘5D’ indicates we want the window for our rolling average to be 5 days.\nwe get a pandas.Series as ouput\n\nStore your answer in the rolling_average variable. You should have two columns in your series, date and the averages.\n\n# Calculate AQI rolling average over 5 days\nrolling_average = aqi_sb['aqi'].rolling(window = '5D').mean()\nrolling_average\n\ndate\n2017-01-01    39.000000\n2017-01-02    39.000000\n2017-01-03    49.666667\n2017-01-04    45.750000\n2017-01-05    44.000000\n                ...    \n2018-12-27    41.200000\n2018-12-28    38.600000\n2018-12-29    38.200000\n2018-12-30    38.200000\n2018-12-31    38.800000\nName: aqi, Length: 730, dtype: float64"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#section-6",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#section-6",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "9",
    "text": "9\nWithout creating any new variables, add the mean of the AQI over a 5-day rolling window as a new column named five_day_average to the aqi_sb dataframe.\n\n# Add calculated rolling averages as 'five_day_average' column\naqi_sb[\"five_day_average\"] = rolling_average\n\naqi_sb\n\n\n\n\n\n\n\n\naqi\ncategory\ndefining_parameter\ndefining_site\nnumber_of_sites_reporting\nfive_day_average\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n2017-01-01\n39\nGood\nOzone\n06-083-4003\n12\n39.000000\n\n\n2017-01-02\n39\nGood\nPM2.5\n06-083-2011\n11\n39.000000\n\n\n2017-01-03\n71\nModerate\nPM10\n06-083-4003\n12\n49.666667\n\n\n2017-01-04\n34\nGood\nOzone\n06-083-4003\n13\n45.750000\n\n\n2017-01-05\n37\nGood\nOzone\n06-083-4003\n12\n44.000000\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n2018-12-27\n37\nGood\nOzone\n06-083-1025\n11\n41.200000\n\n\n2018-12-28\n39\nGood\nOzone\n06-083-1021\n12\n38.600000\n\n\n2018-12-29\n39\nGood\nOzone\n06-083-1021\n12\n38.200000\n\n\n2018-12-30\n41\nGood\nPM2.5\n06-083-1008\n12\n38.200000\n\n\n2018-12-31\n38\nGood\nOzone\n06-083-2004\n12\n38.800000\n\n\n\n\n730 rows × 6 columns"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index_2.html#section-7",
    "href": "blogs/2024-12-02-thomas-fire/index_2.html#section-7",
    "title": "A Beginner’s Python Analysis of the Impacts of the Thomas Fire",
    "section": "10",
    "text": "10\nMake a line plot showing both the daily AQI and the 5-day average (5-day average on top of the AQI). Make necessary updates for the plot to be accurate, informative, and polished, even if simple. You’re welcome to use plotting methods and packages beyond what we have covered in class!\nCan you see the AQI going up during the Thomas Fire in December 2017?\n\n# Define the start and end date of the fire\nfire_start = pd.to_datetime('2017-12-04')\nfire_end = pd.to_datetime('2018-01-12')\n\n# Add span indicating Thomas Fire\nplt.axvspan(fire_start, fire_end, color='#A3210D', alpha = 0.1)\nplt.annotate('--- Thomas Fire', xy = (fire_end, 200), color='#A3210D', alpha = 0.6)\n\n# Add dashed horizontal lines for AQI levels\nplt.axhline(y=151, color='orange', linestyle='--', label='_nolegend_', linewidth=1.5)\nplt.axhline(y=201, color='red', linestyle='--', label='_nolegend_', linewidth=1.5)\nplt.axhline(y=301, color='purple', linestyle='--', label='_nolegend_', linewidth=1.5)\n\n# Add text labels on the lines\nplt.text(aqi_sb.index[0] + pd.Timedelta(days=20), 151, 'Unhealthy (151)', color='orange', fontsize=10, verticalalignment='bottom')\nplt.text(aqi_sb.index[0]+ pd.Timedelta(days=20), 201, 'Very Unhealthy (201)', color='red', fontsize=10, verticalalignment='bottom')\nplt.text(aqi_sb.index[0]+ pd.Timedelta(days=20), 301, 'Hazardous (301)', color='purple', fontsize=10, verticalalignment='bottom')\n\n# Plot AQI\nplt.plot(aqi_sb.index, aqi_sb.aqi, color='#80C4B4', label='Daily')\nplt.plot(aqi_sb.index, aqi_sb.five_day_average, color='#596964', label='5 Day Average')\nplt.title('Visualizing Air Quality Index (AQI) Spike\\nDuring the 2017 Thomas Fire in Santa Barbara County', fontsize=14)\n\n# Plot Customization\nplt.legend()\nplt.xlabel('Date', fontsize=12)\nplt.ylabel('AQI', fontsize=12)\nplt.xticks(rotation=90)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Set figure size (wider plot)\nfig, ax = plt.subplots(figsize=(12, 6)) \n\n# Add vertical span indicating Thomas Fire\nplt.axvspan(pd.to_datetime('2017-12-04'), pd.to_datetime('2018-01-12'), color ='#A3210D', alpha = 0.05)\nplt.annotate('Thomas Fire', xy = (pd.to_datetime('2018-01-12'), 200), xytext = (pd.to_datetime('2018-01-12'), 230),\n             arrowprops=dict(arrowstyle = '-', color='#A3210D'), color='#A3210D', alpha=0.7)\n\n# Add dashed horizontal lines for AQI levels\nplt.axhline(y=151, color = 'orange', linestyle ='--', label ='_nolegend_', linewidth=1.5)\nplt.axhline(y=201, color = 'red', linestyle ='--', label ='_nolegend_', linewidth=1.5)\nplt.axhline(y=301, color = 'purple', linestyle ='--', label ='_nolegend_', linewidth=1.5)\n\n# Add text labels on the lines, moved right by a bit for better placement\nplt.text(aqi_sb.index[0] + pd.Timedelta(days = 20), 151, 'Unhealthy (151)', color ='orange', fontsize=10, verticalalignment='bottom')\nplt.text(aqi_sb.index[0] + pd.Timedelta(days = 20), 201, 'Very Unhealthy (201)', color ='red', fontsize=10, verticalalignment='bottom')\nplt.text(aqi_sb.index[0] + pd.Timedelta(days = 20), 301, 'Hazardous (301)', color ='purple', fontsize=10, verticalalignment='bottom')\n\n# Plot AQI and 5-day average\nplt.plot(aqi_sb.index, aqi_sb.aqi, color='#80C4B4', label='Daily AQI')\nplt.plot(aqi_sb.index, aqi_sb.five_day_average, color='#596964', label='5-Day Average AQI')\n\n# Title and Labels\nplt.title('Air Quality Index (AQI) Spike During the 2017 Thomas Fire in Santa Barbara County', fontsize=16)\nplt.xlabel('Date', fontsize=12)\nplt.ylabel('AQI', fontsize=12)\n\n# Customize ticks\nplt.xticks(rotation =45, ha ='right')\nplt.yticks(range(0, 350, 50))\n\n# Add gridlines for better readability\nplt.grid(True, linestyle ='--', alpha = 0.2)\n\n# Add Legend\nplt.legend(bbox_to_anchor = (1.05, 1), loc = 'upper left', fontsize=10)\n\n# Show plot\nplt.tight_layout()  # Adjust layout to avoid clipping\nplt.show()\n\n\n\n\n\n\n\n\nCan you see the AQI going up during the Thomas Fire in December 2017?\nThis line chart shows Santa Barbara County’s average air quality index (AQI), shown on the y-axis, by day from 2017-2018. The AQI is measured from 0 to 500, which indicates the quality of the air and its health effects with low values indicating the best air quality and higher values indicating lower air quality. The light blue line indicates the Daily Average AQI values, where the dark green line indicates the 5-Day Rolling Average, which takes softens the average based on the surrounding 5 day window. The figure shows a distinct spike in AQI in late 2017, during the Thomas Fire which burned from December 4, 2017 through January 12, 2018. At the start of the fire, the Daily AQI spiked to a harmful index level of over 300. The EPA designates AQI values of 301 and higher to be deemed as “Hazardous” and warns of emergency conditions where everyone, not just senstive populations, is likely to be affected. The figure identifies an additional brief but significant spike in Santa Barbara, where the AQI rose above 200, which the EPA ranks as ‘Very Unhealthy’; this could suggest the occurance of another fire or event that contributed to the dramatic spike.\n\ntitle: “Analyzing Impacts of the Thomas Fire” description: “In Santa Barbara & Ventura Counties (Dec. 2017 - Jan. 2018)” author: - name: Nicole url: https://github.com/nicolelpepper affiliation: Bren MEDS affiliation-url: https://bren.ucsb.edu/masters-programs/master-environmental-data-science/academics-meds-program date: 2024-10-18 categories: [GIS, Remote-Sensing, MEDS] image: thomas-fire.png bibliography: references.bib draft-mode: visible citation: url: https://github.com/nicolelpepper/personalwebsite/2024-12-02-thomas-fire editor_options: chunk_output_type: console"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/index.html",
    "href": "blogs/2024-12-02-thomas-fire/index.html",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "",
    "text": "CitationBibTeX citation:@online{2024,\n  author = {, Nicole},\n  title = {Analyzing {Impacts} of the {Thomas} {Fire}},\n  date = {2024-10-18},\n  url = {https://github.com/nicolelpepper/personalwebsite/2024-12-02-thomas-fire},\n  langid = {en}\n}\nFor attribution, please cite this work as:\nNicole. 2024. “Analyzing Impacts of the Thomas Fire.”\nOctober 18, 2024. https://github.com/nicolelpepper/personalwebsite/2024-12-02-thomas-fire."
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "",
    "text": "Image"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#in-santa-barbara-ventura-counties-dec.-2017---jan.-2018",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#in-santa-barbara-ventura-counties-dec.-2017---jan.-2018",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "In Santa Barbara & Ventura Counties (Dec. 2017 - Jan. 2018)",
    "text": "In Santa Barbara & Ventura Counties (Dec. 2017 - Jan. 2018)\nAuthor: Nicole Pepper\nThe Thomas Fire, which ignited on December 4, 2017, burned approximately 281,893 acres in Ventura and Santa Barbara counties, making it one of the largest and most devastating wildfires in California’s history. The fire left behind extensive burn scars with widespread loss of vegetation and unstable soil, leaving the region vulnerable to erosion. In 2018, heavy rains caused massive flooding and debris flows, which resulted in catastrophic damage and tragic loss of life.\nHere I share my beginner’s Python exercise exploring some of the impacts of the Thomas Fire using satellite imagery and air quality data."
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#part-1.-visualizing-the-thomas-fire-burn-scar-using-false-color",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#part-1.-visualizing-the-thomas-fire-burn-scar-using-false-color",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "Part 1. Visualizing the Thomas Fire burn scar using false color",
    "text": "Part 1. Visualizing the Thomas Fire burn scar using false color\nSatellite data can be used to visualize landscapes beyond what the bare eye can see. In this section I utilize true color and false color settings to visualize the Thomas Fire burn area.\nSome of the technical highlights for this section include working with satellite imagery with rioxr, working with geospatial data with geopandas, and creating a map with matplotlib.\n\nStep 1A: Set up my workspace\nTo begin work this exercise I set up my workspace by loading in the libraries that are necessary for the analysis:\n\n# ---- Load libraries ----\nimport os # interacting with operating system\nimport numpy as np # numeric computing\nimport matplotlib.pyplot as plt # data visualization\nimport pandas as pd # general data wrangling\nimport geopandas as gpd # geospatial data wrangling\nfrom shapely.geometry import Polygon # creating and manipulating geometric objects\nfrom pyproj import CRS # crs management\nimport rioxarray as rioxr # working with raster data\nimport xarray as xr # working with arrays\n\nThen I configure my working environment and establish a directory structure for managing the project data.\n\n# ---- Set working environment ----\n\n# Set anaconda environment\nos.environ['PROJ_LIB'] = '/opt/anaconda3/share/proj'\n\n# Set up a root path directory\nroot = os.path.join('/',\n                  'courses',\n                  'EDS220',\n                  'data',\n                  'hwk4_landsat_data')\n\n\n\nStep 1B: Import & prepare data\nNext it’s time to read in my project data.\nThe thomas_fire.shp is a shapefile containing the fire perimeter for the Thomas Fire in 2017. It is subset of a CAL FIRE dataset with historical boundaries for fires (including both natural and prescribed fires) in the state of California. The dataset has a good record of past large fires but is not complete and may be missing some fires. The thomas_fire.shp data is stored in /data/thomas_fire folder in the repo, I did not push the original full Cal Fire dataset to GitHub, it was accessed locally.\nThe landsat.nc dataset is an image from Landsat Collection 2 Level-2, from the Microsof Planetary Computer data catalogue. Landsat Collection 2 Level-2 Science Products consist of atmospherically corrected surface reflectance and surface temperature image data. Collection 2 Level-2 Science Products are available from August 22, 1982 to present. It is accessed through UCSB Workbench 1 /courses/EDS220/data/hwk4_landsat_data landsat8-2018-01-26-sb-simplified.nc.\n\n# ---- Import data ----\n\n# Import Thomas Fire boundary\nthomas_fire = gpd.read_file(\"data/thomas_fire/thomas_fire.shp\")\n\n# Import landsat .nc file\nfp = os.path.join(root,'landsat8-2018-01-26-sb-simplified.nc')\nlandsat = rioxr.open_rasterio(fp)\n\nNext, I will check the coordinate reference systems (CRS) of the landsat and thomas_fire datasets to ensure 1) the CRS aligns with the needs of the project and 2) the datasets share the same crs, allowing for proper overlay and analysis.\n\n# ---- Check CRS information ----\n\n# Check if landsat is projected \nprint(\"Is the landsat CRS projected?\", landsat.rio.crs.is_projected)\n\n# Check if thomas fire is projected \nprint(\"Is the thomas_fire CRS projected?\", thomas_fire.crs.is_projected)\n\n# Check if crs match\nprint(\"Do the crs match?\", landsat.rio.crs == thomas_fire.crs)\n\n# Print the crs name\nprint(\"The landsat CRS is:\", landsat.rio.crs)\n\n# Print the crs name\nprint(\"The thomas fire CRS is:\", thomas_fire.crs.name)\n\nIs the landsat CRS projected? True\nIs the thomas_fire CRS projected? True\nDo the crs match? False\nThe landsat CRS is: PROJCS[\"WGS 84 / UTM zone 11N\",GEOGCS[\"WGS 84\",DATUM[\"World Geodetic System 1984\",SPHEROID[\"WGS 84\",6378137,298.257223563]],PRIMEM[\"Greenwich\",0],UNIT[\"degree\",0.0174532925199433,AUTHORITY[\"EPSG\",\"9122\"]],AUTHORITY[\"EPSG\",\"4326\"]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"latitude_of_origin\",0],PARAMETER[\"central_meridian\",-117],PARAMETER[\"scale_factor\",0.9996],PARAMETER[\"false_easting\",500000],PARAMETER[\"false_northing\",0],UNIT[\"metre\",1],AXIS[\"Easting\",EAST],AXIS[\"Northing\",NORTH],AUTHORITY[\"EPSG\",\"32611\"]]\nThe thomas fire CRS is: WGS_1984_Web_Mercator_Auxiliary_Sphere\n\n\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\n\n\nMy analysis found that the landsat and thomas_fire crs were both projected, but did not match. This means that we need to reproject the data to match. So next, I’m going to reproject the thomas_fire CRS is to match that landsat CRS which is EPSG 32611 or WGS 84 / UTM Zone 11N.\n\n# ---- Reproject CRS ----\n\n# Reproject to landsat crs\nthomas_fire = thomas_fire.to_crs(landsat.rio.crs)\n\n# Check if crs match\nprint(\"Do the crs match?\", landsat.rio.crs == thomas_fire.crs)\n\nDo the crs match? True\n\n\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\nERROR 1: PROJ: proj_identify: /opt/anaconda3/share/proj/proj.db lacks DATABASE.LAYOUT.VERSION.MAJOR / DATABASE.LAYOUT.VERSION.MINOR metadata. It comes from another PROJ installation.\n\n\n\n\nStep 1C. Explore the Data\nNow that I have my data set up. I’m interested in learning more about the landsat data that I’ll be using. In the next code chunk, I explore different characteristics about my data.\n\n# ---- Explore data ----\n\n# Check out landsat data dimensions\nprint('Size of landsat dimensions: ', dict(landsat.sizes))\n\n# Check out the shape of the landsat data\nprint(\"The shape of Landsat is\", landsat.rio.shape)\n\n# Check out the variables of the landsat data\nprint(\"Variables in the Landsat data:\", list(landsat.data_vars))\n\n# Check out the original coordiantes of the landsat data\nprint(\"Variables in the Landsat data:\", list(landsat.coords))\n\nSize of landsat dimensions:  {'band': 1, 'x': 870, 'y': 731}\nThe shape of Landsat is (731, 870)\nVariables in the Landsat data: ['red', 'green', 'blue', 'nir08', 'swir22']\nVariables in the Landsat data: ['band', 'x', 'y', 'spatial_ref']\n\n\nThe landsat data is 870 by 731 pixels. It has has a total of a band length of 1 and the list of variables in the dataset are ‘red’, ‘green’, ‘blue’, ‘nir08’, and ‘swir22’.\n\n\nStep 1D. Prepare the landsat data for visualization\nSince the landsat data only has one band, I’m going to simplify it by dropping the dimensions that so that it’s easier to work with. To do this, I’ll use .squeeze() and .drop_vars() to remove the band length of 1.\n\n# Remove length 1 dimension (band) and reassign\nlandsat = landsat.squeeze().drop_vars('band', errors='ignore')\n\n# Check updated dimensions of the coordinates\nprint(landsat.dims, landsat.coords)\nprint('Size of landsat dimensions: ', dict(landsat.sizes))\n\nFrozenMappingWarningOnValuesAccess({'x': 870, 'y': 731}) Coordinates:\n  * x            (x) float64 7kB 1.213e+05 1.216e+05 ... 3.557e+05 3.559e+05\n  * y            (y) float64 6kB 3.952e+06 3.952e+06 ... 3.756e+06 3.755e+06\n    spatial_ref  int64 8B 0\nSize of landsat dimensions:  {'x': 870, 'y': 731}\n\n\nI can see that the extra dimension has been removed from the data! Yipee!\n\n\nStep 1E. Visualize the Landsat data in true color\nNow I want to take a look at the landsat data. First off, it would be helpful to see the study area in “natural-color” also known as “true-color’, so that I can get a sense of what the terrain looks like. True-color is a term used by remote sensing experts to describe displaying a satellite image in colors similar to what most people would naturally see with their bare eyes. This means plotting the ‘red’, ‘green’, and ‘blue’ bands in their respective order.\nHere I plot the landsat image in true color (R-G-B) to visualize what the burn area looks like over the region.\n\n# Plot the landsat bands in true color\nlandsat[['red', 'green', 'blue']].to_array().plot.imshow()\n\nplt.title(\"Thomas Fire Study Area\") # Add title\nplt.axis('off') # Removing axis labels and ticks\nplt.show() # Display the plot\n\nClipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).\n\n\n\n\n\n\n\n\n\nHmmmmm…. something here doesn’t look right! The map shows up in black and white when I was expecting it to look like a true color image.\nThis is because the clouds in the image introduce extreme, outlier values. By setting the robust = True parameter in the in .imshow(), I adjust the color scale based on the 2nd and 98th percentiles of the values, which helps minimize the influence of these outliers. This allows the color ramp to more accurately reflect the distribution of values where most of the data lies, providing a clearer representation of the underlying true color patterns in the image.\n\n# Plot the landsat bands in true color\nlandsat[['red', 'green', 'blue']].to_array().plot.imshow(robust=True) # scale on the 2 & 98th percentiles\n\nplt.title(\"Thomas Fire Study Area\") # Add title\nplt.axis('off') # Remove axis labels and ticks\nplt.show() # Display the plot\n\n\n\n\n\n\n\n\nAhhh, much better! Now this is more like what I was expecting to see in my true color image.\nThis map helps me get a feel for what the landscape looks like, but it is still difficult for me to distinguish between landcover like healthy vegetation and bare ground, since the green, brown, and tan colors don’t contrast strongly.\n\n\nStep 1F. Visualize the Landsat data in false\nNext, I’d like to see if I can visualize the burned area better by integrating other bands of the landsat image in a ‘false-color’ composite. False-color images use at least one wavelength outside the visible range, like near-infrared, which can highlight things that we can’t see with our bare eyes.\nVegetation strongly reflects in the near-infrared (NIR) and short-wave infrared (SWIR) bands and absorbs in the red, so visualizing these bands can help me distinguish between healthy vegetated from bare ground. For this reason, I will create a false-color composite using the SWIR, NIR, and red bands (SWIR-NIR-R) to better distinguish between vegetation and the Thomas Fire burned area.\n\n# Select and plot swir, nir, and red variables\nlandsat[['swir22', 'nir08', 'red']].to_array().plot.imshow(robust=True) # scale on the 2 & 98th percentiles\n\nplt.title(\"Thomas Fire Study Area\") # Add title\nplt.axis('off') # Remove axis labels and ticks\nplt.show() # Display the plot\n\n\n\n\n\n\n\n\nThat worked! Now I can much more easily distinguish between vegetation (green) and bare ground or stressed vegetation (tan and red). In the bottom right, I can make out a large irregular red shape which lines up with the area that the Thomas Fire burned.\n\n\nStep 1G. Overlay the Thomas Fire boundary on the false color image\nNow my final step is to overlay the false-color image with the Thomas Fire boundary to see how well the composite image picks up the burned area.\n\n# Select false color SWIR-NIR-red bands and set to array\nfalse_color = landsat[['swir22', 'nir08', 'red']].to_array()\n\n# Set aspect ratio for map\nfire_aspect_ratio = landsat.rio.shape[1] / landsat.rio.shape[0]\n\n# Set figure parameters\nfig, ax = plt.subplots(figsize=(6, 6*fire_aspect_ratio))\n\n# Add false color imagery for background\nfalse_color.plot.imshow(ax = ax,\n                        robust=True) \n# Add thomas fire boundary\nthomas_fire.boundary.plot(ax=ax,\n                color = \"#780B12\",\n                linewidth = 0.6,\n                alpha = 0.8)\n# Add title\nax.set_title('Thomas Fire Boundary (2017)         Southern California',\n            color=\"#222626\", \n            fontsize=12)\n\nax.axis('off') # Remove axis labels and ticks\nplt.legend(thomas_fire,loc='upper right', labels = [\"Thomas Fire\"]) # add legend\nplt.show() # Display the plot\n\n/tmp/ipykernel_3552418/3966502035.py:24: UserWarning: You have mixed positional and keyword arguments, some input may be discarded.\n  plt.legend(thomas_fire,loc='upper right', labels = [\"Thomas Fire\"]) # add legend\n\n\n\n\n\n\n\n\n\nThis map shows the burn perimeter, outlined in dark red, for the Thomas Fire which occured in 2017. The boundary is overlayed onto a false color satellite image of the region, combining short-wave infrared (SWIR), near-infrared (NIR), and red bands to highlight vegetation (green) versus the burn scar (red). This overlay shows that the boundary of the burn scar aligns well with area in red in false color composite. When looking back at the true color image, this false-color map demonstrates the ability of the false color images to pick out land surface characteristics beyond what our bare eyes can see.\n\n# Display all columns in preview\npd.set_option(\"display.max.columns\", None)"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#section",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#section",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "3",
    "text": "3\n\nand b. Use the next two code cells to look at the head of both data frames. Store your results in aqi_17_head and aqi_18_head.\n\n\n# a.\n# Look at the head, first 5 entries, of the AQI 2017 data\naqi_17_head = aqi_17.head()\n\n\n# b.\n# Look at the head, first 5 entries, of the AQI 2018 data\naqi_18_head = aqi_18.head()\n\nANSWER: - I used dtypes to see the data types for the different columns. - I used max and min to find the max and min AQI values for the datasets. - I used value_counts to find the value counts of observations that fell in the different Category Ratings\nI found that the means were similar between the years but the max for 2017 was much higher. I also found that in 2017 there were more ‘Hazardous’(71) category ratings than in 2018(30), which indicates that the presence of events in 2017 that contributed to low air quality.*"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#section-1",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#section-1",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "4",
    "text": "4\nWe currently have two separate data frames. For this exercise we will need to “glue” them one on top of the other. The pandas function pd.concat() can achieve this.\nPass [aqi_17, aqi_18] as the input of pd.concat() and store the output as aqi.\nIn the next line run aqi.\nNOTE: When we concatenate data frames like this, without any extra parameters for pd.concat() the indices for the two dataframes are just “glued together”, the index of the resulting dataframe is not updated to start from 0. Notice the mismatch between the index of aqi and the number of rows i the complete data frame.\n\n# Combine the two datasets using `pd.concat`\naqi = pd.concat([aqi_17, aqi_18])"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#section-2",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#section-2",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "5",
    "text": "5\nRun the following code cell and use the next markdown cell to give a line by line explanation of the code below the comment “#Simplify column names”. You might need to look up the pandas documentation.\n\n# Initial column names: notice caps and spaces (difficult to work with!)\nprint(aqi.columns, '\\n')\n\n# Simplify column names\naqi.columns = (aqi.columns\n                  .str.lower()\n                  .str.replace(' ','_')\n                )\nprint(aqi.columns, '\\n')\n\nIndex(['State Name', 'county Name', 'State Code', 'County Code', 'Date', 'AQI',\n       'Category', 'Defining Parameter', 'Defining Site',\n       'Number of Sites Reporting'],\n      dtype='object') \n\nIndex(['state_name', 'county_name', 'state_code', 'county_code', 'date', 'aqi',\n       'category', 'defining_parameter', 'defining_site',\n       'number_of_sites_reporting'],\n      dtype='object') \n\n\n\n\nLine by line explanation of above code\nANSWER:\n# Initial column names: notice caps and spaces (difficult to work with!)\nprint(aqi.columns, '\\n')               # Prints original column names and sets a new text line\n\n# Clean column names\naqi.columns = (aqi.columns # Select columns of the aqi dataframe      \n        .str.lower()  # Set text in column names to be lowercase\n                  .str.replace(' ','_')  # Replace spaces with underscore in column names\n              )\n              \n# Confirm column names updated successfully**\n- print(aqi.columns, '\\n')  # Print updated column names and sets a new text line"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#section-3",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#section-3",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "6",
    "text": "6\nIn the next code cell:\n\nSelect only data from Santa Barbara county and store it in a new variable aqi_sb.\nRemove the state_name, county_name, state_code and county_code columns from aqi_sb.\n\nYour dataframe should have the following columns in this order: date, aqi, category, defining_parameter, defining_stie, number_of_sites_reporting.\n\n# part a\n# Subset AQI data to Santa Barbara county\naqi_sb = aqi[aqi['county_name'] == 'Santa Barbara']\n\n# part b\n# Remove the 'state_name', 'county_name', 'state_code' and 'county_code' columns from aqi_sb\naqi_sb = aqi_sb.drop(['state_name', 'county_name', 'state_code', 'county_code'], axis = 1)\n\n\n\nWhat is the data type of the date column? Store your answer in the date_type variable. Your answer should contain the type for the date column only.\n\n\n# Check the type of date column\ndate_type = type(aqi_sb.date)"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#section-4",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#section-4",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "7",
    "text": "7\nIn the following cell: 1. Update the date column of aqi_sb to be a pandas.datetime object. 2. Update the index of aqi_sb to be the date column.\n\n# part a\n# Update the data column to datetime object\naqi_sb.date = pd.to_datetime(aqi_sb.date)\n\n# part b\n# Set date as the index of aqi_sb\naqi_sb = aqi_sb.set_index('date')"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#section-5",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#section-5",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "8",
    "text": "8\nIn the next cell we will calculate an average over a rolling window using the rolling()method for pandas.Series:\n\nrolling() is a lazy method, so we need to specify what we want to calculate over each window before it does something.\nin this example we use the aggregator function mean() to calculate the average over each window\nthe parameter ‘5D’ indicates we want the window for our rolling average to be 5 days.\nwe get a pandas.Series as ouput\n\nStore your answer in the rolling_average variable. You should have two columns in your series, date and the averages.\n\n# Calculate AQI rolling average over 5 days\nrolling_average = aqi_sb['aqi'].rolling(window = '5D').mean()\nrolling_average\n\ndate\n2017-01-01    39.000000\n2017-01-02    39.000000\n2017-01-03    49.666667\n2017-01-04    45.750000\n2017-01-05    44.000000\n                ...    \n2018-12-27    41.200000\n2018-12-28    38.600000\n2018-12-29    38.200000\n2018-12-30    38.200000\n2018-12-31    38.800000\nName: aqi, Length: 730, dtype: float64"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#section-6",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#section-6",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "9",
    "text": "9\nWithout creating any new variables, add the mean of the AQI over a 5-day rolling window as a new column named five_day_average to the aqi_sb dataframe.\n\n# Add calculated rolling averages as 'five_day_average' column\naqi_sb[\"five_day_average\"] = rolling_average\n\naqi_sb\n\n\n\n\n\n\n\n\naqi\ncategory\ndefining_parameter\ndefining_site\nnumber_of_sites_reporting\nfive_day_average\n\n\ndate\n\n\n\n\n\n\n\n\n\n\n2017-01-01\n39\nGood\nOzone\n06-083-4003\n12\n39.000000\n\n\n2017-01-02\n39\nGood\nPM2.5\n06-083-2011\n11\n39.000000\n\n\n2017-01-03\n71\nModerate\nPM10\n06-083-4003\n12\n49.666667\n\n\n2017-01-04\n34\nGood\nOzone\n06-083-4003\n13\n45.750000\n\n\n2017-01-05\n37\nGood\nOzone\n06-083-4003\n12\n44.000000\n\n\n...\n...\n...\n...\n...\n...\n...\n\n\n2018-12-27\n37\nGood\nOzone\n06-083-1025\n11\n41.200000\n\n\n2018-12-28\n39\nGood\nOzone\n06-083-1021\n12\n38.600000\n\n\n2018-12-29\n39\nGood\nOzone\n06-083-1021\n12\n38.200000\n\n\n2018-12-30\n41\nGood\nPM2.5\n06-083-1008\n12\n38.200000\n\n\n2018-12-31\n38\nGood\nOzone\n06-083-2004\n12\n38.800000\n\n\n\n\n730 rows × 6 columns"
  },
  {
    "objectID": "blogs/2024-12-02-thomas-fire/test_3.html#section-7",
    "href": "blogs/2024-12-02-thomas-fire/test_3.html#section-7",
    "title": "Analyzing Impacts of the Thomas Fire",
    "section": "10",
    "text": "10\nMake a line plot showing both the daily AQI and the 5-day average (5-day average on top of the AQI). Make necessary updates for the plot to be accurate, informative, and polished, even if simple. You’re welcome to use plotting methods and packages beyond what we have covered in class!\nCan you see the AQI going up during the Thomas Fire in December 2017?\n\n# Define the start and end date of the fire\nfire_start = pd.to_datetime('2017-12-04')\nfire_end = pd.to_datetime('2018-01-12')\n\n# Add span indicating Thomas Fire\nplt.axvspan(fire_start, fire_end, color='#A3210D', alpha = 0.1)\nplt.annotate('--- Thomas Fire', xy = (fire_end, 200), color='#A3210D', alpha = 0.6)\n\n# Add dashed horizontal lines for AQI levels\nplt.axhline(y=151, color='orange', linestyle='--', label='_nolegend_', linewidth=1.5)\nplt.axhline(y=201, color='red', linestyle='--', label='_nolegend_', linewidth=1.5)\nplt.axhline(y=301, color='purple', linestyle='--', label='_nolegend_', linewidth=1.5)\n\n# Add text labels on the lines\nplt.text(aqi_sb.index[0] + pd.Timedelta(days=20), 151, 'Unhealthy (151)', color='orange', fontsize=10, verticalalignment='bottom')\nplt.text(aqi_sb.index[0]+ pd.Timedelta(days=20), 201, 'Very Unhealthy (201)', color='red', fontsize=10, verticalalignment='bottom')\nplt.text(aqi_sb.index[0]+ pd.Timedelta(days=20), 301, 'Hazardous (301)', color='purple', fontsize=10, verticalalignment='bottom')\n\n# Plot AQI\nplt.plot(aqi_sb.index, aqi_sb.aqi, color='#80C4B4', label='Daily')\nplt.plot(aqi_sb.index, aqi_sb.five_day_average, color='#596964', label='5 Day Average')\nplt.title('Visualizing Air Quality Index (AQI) Spike\\nDuring the 2017 Thomas Fire in Santa Barbara County', fontsize=14)\n\n# Plot Customization\nplt.legend()\nplt.xlabel('Date', fontsize=12)\nplt.ylabel('AQI', fontsize=12)\nplt.xticks(rotation=90)\nplt.show()\n\n\n\n\n\n\n\n\n\n# Set figure size (wider plot)\nfig, ax = plt.subplots(figsize=(12, 6)) \n\n# Add vertical span indicating Thomas Fire\nplt.axvspan(pd.to_datetime('2017-12-04'), pd.to_datetime('2018-01-12'), color ='#A3210D', alpha = 0.05)\nplt.annotate('Thomas Fire', xy = (pd.to_datetime('2018-01-12'), 200), xytext = (pd.to_datetime('2018-01-12'), 230),\n             arrowprops=dict(arrowstyle = '-', color='#A3210D'), color='#A3210D', alpha=0.7)\n\n# Add dashed horizontal lines for AQI levels\nplt.axhline(y=151, color = 'orange', linestyle ='--', label ='_nolegend_', linewidth=1.5)\nplt.axhline(y=201, color = 'red', linestyle ='--', label ='_nolegend_', linewidth=1.5)\nplt.axhline(y=301, color = 'purple', linestyle ='--', label ='_nolegend_', linewidth=1.5)\n\n# Add text labels on the lines, moved right by a bit for better placement\nplt.text(aqi_sb.index[0] + pd.Timedelta(days = 20), 151, 'Unhealthy (151)', color ='orange', fontsize=10, verticalalignment='bottom')\nplt.text(aqi_sb.index[0] + pd.Timedelta(days = 20), 201, 'Very Unhealthy (201)', color ='red', fontsize=10, verticalalignment='bottom')\nplt.text(aqi_sb.index[0] + pd.Timedelta(days = 20), 301, 'Hazardous (301)', color ='purple', fontsize=10, verticalalignment='bottom')\n\n# Plot AQI and 5-day average\nplt.plot(aqi_sb.index, aqi_sb.aqi, color='#80C4B4', label='Daily AQI')\nplt.plot(aqi_sb.index, aqi_sb.five_day_average, color='#596964', label='5-Day Average AQI')\n\n# Title and Labels\nplt.title('Air Quality Index (AQI) Spike During the 2017 Thomas Fire in Santa Barbara County', fontsize=16)\nplt.xlabel('Date', fontsize=12)\nplt.ylabel('AQI', fontsize=12)\n\n# Customize ticks\nplt.xticks(rotation =45, ha ='right')\nplt.yticks(range(0, 350, 50))\n\n# Add gridlines for better readability\nplt.grid(True, linestyle ='--', alpha = 0.2)\n\n# Add Legend\nplt.legend(bbox_to_anchor = (1.05, 1), loc = 'upper left', fontsize=10)\n\n# Show plot\nplt.tight_layout()  # Adjust layout to avoid clipping\nplt.show()\n\n\n\n\n\n\n\n\nCan you see the AQI going up during the Thomas Fire in December 2017?\nThis line chart shows Santa Barbara County’s average air quality index (AQI), shown on the y-axis, by day from 2017-2018. The AQI is measured from 0 to 500, which indicates the quality of the air and its health effects with low values indicating the best air quality and higher values indicating lower air quality. The light blue line indicates the Daily Average AQI values, where the dark green line indicates the 5-Day Rolling Average, which takes softens the average based on the surrounding 5 day window. The figure shows a distinct spike in AQI in late 2017, during the Thomas Fire which burned from December 4, 2017 through January 12, 2018. At the start of the fire, the Daily AQI spiked to a harmful index level of over 300. The EPA designates AQI values of 301 and higher to be deemed as “Hazardous” and warns of emergency conditions where everyone, not just senstive populations, is likely to be affected. The figure identifies an additional brief but significant spike in Santa Barbara, where the AQI rose above 200, which the EPA ranks as ‘Very Unhealthy’; this could suggest the occurance of another fire or event that contributed to the dramatic spike.\n\ntitle: “Analyzing Impacts of the Thomas Fire” description: “In Santa Barbara & Ventura Counties (Dec. 2017 - Jan. 2018)” author: - name: Nicole url: https://github.com/nicolelpepper affiliation: Bren MEDS affiliation-url: https://bren.ucsb.edu/masters-programs/master-environmental-data-science/academics-meds-program date: 2024-10-18 categories: [GIS, Remote-Sensing, MEDS] image: thomas-fire.png bibliography: references.bib draft-mode: visible citation: url: https://github.com/nicolelpepper/personalwebsite/2024-12-02-thomas-fire editor_options: chunk_output_type: console"
  },
  {
    "objectID": "blogs/2024-10-18-test-post/index.html",
    "href": "blogs/2024-10-18-test-post/index.html",
    "title": "Blog Post Title",
    "section": "",
    "text": "I’m going to insert a footnote here1"
  },
  {
    "objectID": "blogs/2024-10-18-test-post/index.html#this-is-my-first-section",
    "href": "blogs/2024-10-18-test-post/index.html#this-is-my-first-section",
    "title": "Blog Post Title",
    "section": "",
    "text": "I’m going to insert a footnote here1"
  },
  {
    "objectID": "blogs/2024-10-18-test-post/index.html#this-is-my-second-section",
    "href": "blogs/2024-10-18-test-post/index.html#this-is-my-second-section",
    "title": "Blog Post Title",
    "section": "This is my second section",
    "text": "This is my second section\nHere is my next paragraph2"
  },
  {
    "objectID": "blogs/2024-10-18-test-post/index.html#this-is-my-third-section",
    "href": "blogs/2024-10-18-test-post/index.html#this-is-my-third-section",
    "title": "Blog Post Title",
    "section": "This is my third section",
    "text": "This is my third section\nI’m citing me(Csik 2022)\nIm adding another citation: (Gaynor et al. 2022)"
  },
  {
    "objectID": "blogs/2024-10-18-test-post/index.html#footnotes",
    "href": "blogs/2024-10-18-test-post/index.html#footnotes",
    "title": "Blog Post Title",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nHere is my footnote↩︎\nHere is my second footnote↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Some text goes here"
  },
  {
    "objectID": "about.html#what-i-do-for-work",
    "href": "about.html#what-i-do-for-work",
    "title": "About",
    "section": "",
    "text": "Some text goes here"
  },
  {
    "objectID": "about.html#what-i-do-for-fun",
    "href": "about.html#what-i-do-for-fun",
    "title": "About",
    "section": "What I do for fun",
    "text": "What I do for fun\nSome text goes here\nhere is some text\nhere is some more text"
  },
  {
    "objectID": "about.html#what-i-do-for-fun-1",
    "href": "about.html#what-i-do-for-fun-1",
    "title": "About",
    "section": "What I do for fun",
    "text": "What I do for fun\nSome text goes here"
  }
]